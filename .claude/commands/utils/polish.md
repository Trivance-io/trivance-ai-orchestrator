---
description: Meticulous polishing of any AI-generated file eliminating errors, inconsistencies, and quality issues
argument-hint: "file paths | directory | any AI-generated content requiring refinement"
allowed-tools: Read, Write, Edit, MultiEdit, Bash, Grep, LS, Glob, Task, TodoWrite
---

# File Polishing Protocol

**Systematic refinement for AI-generated content:** $ARGUMENTS

## ⚠️ CRITICAL DISCLAIMER - MANDATORY COMPLIANCE

**POLISHING ≠ SCOPE REDUCTION**

This command is for **REFINEMENT**, not **FUNCTIONAL REDUCTION**. Before any changes:

1. **ANALYZE PURPOSE FIRST** - Understand the file's core mission and intended scope
2. **PRESERVE 100% FUNCTIONALITY** - Never sacrifice features for brevity
3. **DISTINGUISH POLISH FROM SIMPLIFY** - Format improvements ≠ capability reduction
4. **WHEN IN DOUBT, DON'T REDUCE** - Err on the side of preserving functionality

**EXAMPLES OF CORRECT POLISHING:**

- Fix syntax errors, inconsistent formatting, broken links
- Eliminate promotional language, redundant explanations
- Standardize naming conventions, improve clarity
- Remove duplicate information, optimize structure

**EXAMPLES OF INCORRECT REDUCTION:**

- Removing methodology sections from analysis commands
- Cutting algorithm logic for "brevity"
- Eliminating core features to "simplify"
- Reducing command capabilities for "efficiency"

**MANDATE: If file serves critical user workflow (daily use, core functionality), prioritize COMPLETE PRESERVATION over optimization.**

## Universal Polishing Protocol

Execute systematically across all file types:

### Phase 1: Syntax & Structure Validation

1. **Documentation Files** (.md, .rst, .txt) - Header hierarchy, link syntax, formatting consistency
2. **Configuration Files** (.json, .yaml, .env) - Valid syntax, proper indentation, required fields
3. **Data Files** (.csv, .sql, .xml) - Format compliance, delimiter consistency, schema validation
4. **Code Files** (any language) - Syntax correctness, imports, declaration integrity
5. **Scripts & Templates** (.sh, .html, .css) - Command syntax, tag matching, style consistency

### Phase 2: Logical Coherence Audit

6. **Information Flow** - Logical progression, complete procedures, accurate cross-references
7. **Configuration Logic** - Setting interdependencies, no conflicting options, appropriate defaults
8. **Data Integrity** - Referential consistency, type matching, constraint compliance
9. **Functional Logic** - Dead code elimination, proper error handling, edge case coverage
10. **Template Logic** - Variable consistency, conditional logic, proper inheritance

### Phase 3: Consistency & Standards Enforcement

11. **Naming Conventions** - Consistent patterns within file type (camelCase, snake_case, kebab-case)
12. **Format Standardization** - Uniform spacing, indentation, bracket/quote styles
13. **Language Standards** - File-type specific best practices and conventions
14. **Cross-file Consistency** - Matching patterns when working with multiple files
15. **Professional Standards** - Industry-standard formatting and structure

### Phase 4: Redundancy & Optimization Elimination

16. **Content Duplication** - Repeated sections, redundant information, copy-paste blocks
17. **Unused Elements** - Dead links, unused configurations, orphaned references
18. **Complexity Reduction** - Unnecessary nesting, overcomplicated structures
19. **Performance Optimization** - Efficient data structures, optimized queries, lean configurations
20. **Resource Cleanup** - Unused imports, unnecessary dependencies, bloated content

### Phase 5: Communication & Content Quality

21. **Professional Language** - Use clear, concise, technical language
22. **Documentation Clarity** - Ensure accurate descriptions and complete information
23. **Content Accuracy** - Verify factual correctness and precise terminology

## File-Type Specific Considerations

- **Documentation Files** (.md, .rst, .txt): Header hierarchy, link validity, list consistency, promotional language elimination
- **Configuration Files** (.json, .yaml, .toml, .env): Syntax validation, setting conflicts, security risks, missing dependencies
- **Data Files** (.csv, .sql, .xml, .json): Format compliance, type consistency, constraint validation, encoding issues
- **Scripts & Templates** (.sh, .ps1, .html, .css): Command syntax, error handling, security validation, accessibility compliance
- **Code Files** (any language): Language-specific syntax, import optimization, logic validation, architecture compliance

## Execution Process

1. **File Analysis** - Identify format and understand purpose
2. **Apply Standards** - Use relevant style guides and conventions
3. **Execute Five Phases** - Complete each phase sequentially
4. **Validate Results** - Ensure functionality and compliance
5. **Document Changes** - Record improvements and rationale

## Zero-Tolerance Polish Standards

**Mandatory fixes:**

### Critical Issues (Must Fix)

1. **Syntax Errors** - Any malformed content that breaks functionality
2. **Security Vulnerabilities** - Exposed secrets, injection risks, permissions
3. **Broken References** - Dead links, missing files, invalid imports
4. **Data Corruption** - Type mismatches, constraint violations, encoding issues
5. **Functional Failures** - Logic errors that prevent intended operation

### High Priority Issues (Strong Recommendation)

1. **Inconsistent Formatting** - Mixed styles, irregular patterns
2. **Performance Problems** - Inefficient structures, redundant operations
3. **Clarity Issues** - Unclear documentation, confusing instructions
4. **Standard Violations** - Non-compliance with established conventions
5. **Redundant Content** - Duplicate information, unnecessary repetition

### Content Quality Standards

- **Professional Language** - Use clear, technical communication without promotional content
- **Technical Accuracy** - Verify all facts, examples, and procedures
- **Completeness** - Ensure all necessary information is present
- **Clarity** - Maintain clear, unambiguous communication
- **Consistency** - Apply uniform style and terminology throughout

## Implementation Guidelines

**Core Principles:**

- Deliver ≥ 2x value vs complexity
- Maintain functionality while reducing complexity
- Ensure production-ready output
- Document all changes with clear rationale

**Execution Protocol:**

Follow the systematic 5-step Execution Process detailed above, ensuring all phases are completed sequentially with full documentation of improvements.
