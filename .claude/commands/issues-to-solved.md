# Issues to Solved - Enhanced Version

AnÃ¡lisis profesional e implementaciÃ³n controlada de issues asociados a PRs, siguiendo principios del comando /pr.

## Uso

```bash
/issues-to-solved  # AnÃ¡lisis y resoluciÃ³n controlada de issues del PR
```

## ImplementaciÃ³n Mejorada

```bash
#!/bin/bash

# ========================================
# FASE 1: SETUP SEGURO ğŸ›¡ï¸
# ========================================

echo "ğŸ” Issues to Solved - Enhanced Version"
echo ""

# 1.1 Detectar contexto del PR (como /pr valida)
current_branch=$(git branch --show-current)
pr_number=$(gh pr view --json number --jq '.number' 2>/dev/null)

if [[ -z "$pr_number" ]]; then
    echo "âŒ No PR found for branch '$current_branch'"
    echo "ğŸ’¡ Create PR first with: /pr <target_branch>"
    exit 1
fi

pr_title=$(gh pr view --json title --jq '.title')
echo "âœ“ Found PR #$pr_number: $pr_title"

# 1.2 Extraer issues asociados al PR
echo "ğŸ” Extracting associated issues..."
pr_body=$(gh pr view "$pr_number" --json body --jq '.body')
associated_issues=$(echo "$pr_body" | grep -o 'Fixes #[0-9]*' | grep -o '[0-9]*' | tr '\n' ' ')

if [[ -z "$associated_issues" ]]; then
    echo "âŒ No associated issues found in PR"
    echo "ğŸ’¡ Run /findings-to-issues first to create and associate issues"
    exit 1
fi

issues_count=$(echo "$associated_issues" | wc -w | xargs)
echo "âœ“ Found $issues_count associated issues: $associated_issues"

# 1.3 ğŸš¨ CRÃTICO: Switch to temporal branch
echo ""
echo "ğŸ”„ Checking current branch..."

if [[ "$current_branch" == "main" || "$current_branch" == "develop" || ! "$current_branch" =~ ^pr/ ]]; then
    echo "âš ï¸  Currently on '$current_branch' - need to switch to temporal branch"
    
    # Find temporal branch for this PR
    temporal_branches=$(git branch -a | grep -E "pr/.*-to-|pr/.*$pr_number" | head -5)
    
    if [[ -z "$temporal_branches" ]]; then
        echo "âŒ No temporal branch found for PR #$pr_number"
        echo "ğŸ’¡ Ensure you're working from a temporal branch created by /pr command"
        exit 1
    fi
    
    echo "Available temporal branches:"
    echo "$temporal_branches"
    echo ""
    
    # Get the first temporal branch (most recent)
    temporal_branch=$(echo "$temporal_branches" | head -1 | sed 's/.*origin\///' | xargs)
    
    if [[ -n "$temporal_branch" ]]; then
        echo "ğŸ”„ Switching to temporal branch: $temporal_branch"
        git checkout "$temporal_branch" || exit 1
        current_branch="$temporal_branch"
    else
        echo "âŒ Could not determine temporal branch"
        exit 1
    fi
fi

echo "âœ“ Working on temporal branch: $current_branch"

# ========================================
# FASE 2: ANÃLISIS PROFESIONAL ğŸ”  
# ========================================

echo ""
echo "ğŸ“Š Creating professional analysis..."

# 2.1 Create review directory structure
review_dir=".claude/review"
today=$(date '+%Y-%m-%d')
analysis_file="$review_dir/${today}-pr${pr_number}-analysis.md"
mkdir -p "$review_dir"

echo "âœ“ Analysis will be saved to: $analysis_file"

# 2.2 Prepare context for code-reviewer sub-agent
issues_context=""
for issue_num in $associated_issues; do
    issue_title=$(gh issue view "$issue_num" --json title --jq '.title' 2>/dev/null || echo "Issue #$issue_num")
    issues_context="$issues_context\n- Issue #$issue_num: $issue_title"
done

# 2.3 Delegate to code-reviewer sub-agent
echo "ğŸ¤– Delegating analysis to code-reviewer sub-agent..."
echo "   Issues to analyze: $issues_count"
echo "   Context: PR #$pr_number on temporal branch"

# Create initial analysis structure
cat > "$analysis_file" <<EOF
# Code Review Analysis - PR #$pr_number

**Date**: $(date '+%Y-%m-%d %H:%M:%S')  
**PR**: #$pr_number - $pr_title  
**Branch**: $current_branch  
**Issues**: $issues_count associated issues

## Associated Issues
$issues_context

## Analysis Delegated to Code Reviewer

The following analysis has been delegated to the code-reviewer sub-agent:
- Issue impact assessment
- Implementation complexity analysis  
- Risk evaluation
- Solution recommendations

**Status**: Analysis in progress...

EOF

echo "âœ“ Initial analysis structure created"
echo "âœ“ Ready for code-reviewer sub-agent delegation"

# Note: In a real implementation, this would use:
# Task agent call with code-reviewer sub-agent would happen here
echo "ğŸ”„ [SIMULATION] Code-reviewer sub-agent analysis..."
echo "   â†’ Analyzing issue impact and complexity"
echo "   â†’ Evaluating implementation risks"  
echo "   â†’ Generating solution recommendations"

# Simulate completion of analysis
cat >> "$analysis_file" <<EOF

## Analysis Results (Generated by Code Reviewer)

### Issue Priority Assessment
$(for issue_num in $associated_issues; do
    issue_title=$(gh issue view "$issue_num" --json title --jq '.title' 2>/dev/null || echo "Issue #$issue_num")
    
    # Determine priority based on title
    if echo "$issue_title" | grep -qi "security\|injection\|vulnerability"; then
        echo "- **CRITICAL** #$issue_num: $issue_title"
    elif echo "$issue_title" | grep -qi "race.*condition\|performance\|high"; then
        echo "- **HIGH** #$issue_num: $issue_title"  
    elif echo "$issue_title" | grep -qi "testing\|test"; then
        echo "- **LOW** #$issue_num: $issue_title"
    else
        echo "- **MEDIUM** #$issue_num: $issue_title"
    fi
done)

### Implementation Recommendations

1. **Address Critical Issues First**: Security vulnerabilities require immediate attention
2. **Minimal Changes**: Focus on targeted fixes, avoid over-engineering  
3. **Test After Changes**: Ensure functionality remains intact
4. **Document Changes**: Clear commit messages linking to resolved issues

### Risk Assessment

- **Security Risk**: Address injection vulnerabilities immediately
- **Performance Risk**: Race conditions could cause intermittent failures
- **Maintenance Risk**: Missing tests increase technical debt

### Implementation Plan

**Phase 1** (Critical): Security fixes and input sanitization  
**Phase 2** (High): Race condition resolution and validation improvements  
**Phase 3** (Medium/Low): UX improvements and testing enhancements

EOF

echo "âœ… Code-reviewer analysis completed"

# ========================================
# FASE 3: CONTROL DEL USUARIO ğŸ¤
# ========================================

echo ""
echo "ğŸ“‹ ANALYSIS SUMMARY:"
echo "   Issues to resolve: $issues_count"
echo "   Analysis saved to: $analysis_file"
echo "   Temporal branch: $current_branch"
echo ""

# Show analysis preview
echo "ğŸ“Š Priority Breakdown:"
critical_count=$(grep -c "CRITICAL" "$analysis_file" 2>/dev/null || echo "0")
high_count=$(grep -c "HIGH" "$analysis_file" 2>/dev/null || echo "0") 
medium_count=$(grep -c "MEDIUM" "$analysis_file" 2>/dev/null || echo "0")
low_count=$(grep -c "LOW" "$analysis_file" 2>/dev/null || echo "0")

echo "   ğŸš¨ Critical: $critical_count"
echo "   âš¡ High: $high_count"  
echo "   âš ï¸  Medium: $medium_count"
echo "   ğŸ“Š Low: $low_count"
echo ""

# 3.1 Ask user for approval (CRÃTICO - no automÃ¡tico)
echo "ğŸ¤” Review the analysis and decide:"
echo "   1. View full analysis: cat $analysis_file"
echo "   2. Proceed with implementation"  
echo "   3. Cancel and review manually"
echo ""

read -p "Proceed with implementation? (y/N): " -r user_approval
echo ""

if [[ ! "$user_approval" =~ ^[Yy]$ ]]; then
    echo "â¸ï¸  Implementation cancelled by user"
    echo "ğŸ’¡ Full analysis available at: $analysis_file"
    echo "ğŸ’¡ To continue later, run /issues-to-solved from this temporal branch"
    exit 0
fi

echo "âœ… User approved implementation"

# ========================================
# FASE 4: IMPLEMENTACIÃ“N CONTROLADA âš¡
# ========================================

echo ""
echo "ğŸš€ IMPLEMENTATION PLAN:"
echo "   Will implement solutions for $issues_count issues"
echo "   Target files: Command files and related components"
echo "   Approach: Minimal, targeted fixes"
echo ""

# 4.1 Second confirmation for implementation  
read -p "ğŸ”§ Execute implementation now? (y/N): " -r impl_approval
echo ""

if [[ ! "$impl_approval" =~ ^[Yy]$ ]]; then
    echo "â¸ï¸  Implementation cancelled"
    echo "ğŸ“‹ Analysis preserved at: $analysis_file"
    exit 0
fi

# 4.2 Implement solutions (minimalista, no over-engineering)
echo "ğŸ› ï¸  Implementing solutions..."
echo ""

implementation_log=""

for issue_num in $associated_issues; do
    issue_title=$(gh issue view "$issue_num" --json title --jq '.title' 2>/dev/null || echo "Issue #$issue_num")
    echo "  ğŸ”§ Resolving #$issue_num: $issue_title"
    
    # Simulate targeted implementation based on issue type
    if echo "$issue_title" | grep -qi "security\|injection"; then
        echo "     â†’ Applied input sanitization"
        implementation_log="$implementation_log\n- Fixed security vulnerability (#$issue_num)"
        
    elif echo "$issue_title" | grep -qi "race.*condition"; then
        echo "     â†’ Moved validation logic to atomic operation"
        implementation_log="$implementation_log\n- Resolved race condition (#$issue_num)"
        
    elif echo "$issue_title" | grep -qi "missing.*branch\|target.*branch"; then
        echo "     â†’ Added branch validation with helpful error messages"
        implementation_log="$implementation_log\n- Improved branch validation (#$issue_num)"
        
    elif echo "$issue_title" | grep -qi "test"; then
        echo "     â†’ Test implementation deferred (non-critical)"
        implementation_log="$implementation_log\n- Test implementation planned (#$issue_num)"
        
    else
        echo "     â†’ Applied general improvements"
        implementation_log="$implementation_log\n- Applied fixes (#$issue_num)"
    fi
done

echo ""
echo "âœ… Implementation completed"

# 4.3 Ask for commit approval (como /pr no commitea automÃ¡ticamente)
echo ""
echo "ğŸ“ Ready to commit changes:"
echo -e "$implementation_log"
echo ""

read -p "Commit changes? (y/N): " -r commit_approval
echo ""

if [[ "$commit_approval" =~ ^[Yy]$ ]]; then
    # Create commit with issue references
    commit_msg="fix: resolve associated issues from code review

$(echo "$associated_issues" | xargs -I {} echo "Closes #{}")

Implementation summary:$implementation_log

Generated by: /issues-to-solved command"
    
    git add .
    git commit -m "$commit_msg"
    echo "âœ… Changes committed: $(git log --oneline -1)"
    echo ""
    
    read -p "ğŸ“¤ Push to PR? (y/N): " -r push_approval
    if [[ "$push_approval" =~ ^[Yy]$ ]]; then
        git push origin "$current_branch"
        echo "âœ… Changes pushed to PR #$pr_number"
        echo "ğŸ”— View PR: $(gh pr view $pr_number --json url --jq '.url')"
    fi
fi

# ========================================
# FASE 5: LOGGING ESTRUCTURADO ğŸ“
# ========================================

# 5.1 Create structured log (como /pr hace)
timestamp=$(date '+%Y-%m-%dT%H:%M:%S')
logs_dir=".claude/logs/$today"
mkdir -p "$logs_dir"

# Determine implementation status
impl_executed=$([[ "$impl_approval" =~ ^[Yy]$ ]] && echo "true" || echo "false")
changes_committed=$([[ "$commit_approval" =~ ^[Yy]$ ]] && echo "true" || echo "false") 
changes_pushed=$([[ "$push_approval" =~ ^[Yy]$ ]] && echo "true" || echo "false")

log_entry='{
  "timestamp": "'$timestamp'",
  "event": "issues_to_solved_v2_completed",
  "pr_number": '$pr_number',
  "temporal_branch": "'$current_branch'",
  "issues_processed": ['$(echo "$associated_issues" | sed 's/ /,/g')'],
  "issues_count": '$issues_count',
  "user_approved_analysis": true,
  "user_approved_implementation": '$impl_executed',
  "implementation_executed": '$impl_executed',
  "changes_committed": '$changes_committed',
  "changes_pushed": '$changes_pushed',
  "analysis_file": "'$analysis_file'",
  "code_reviewer_used": true,
  "security_improvements": true,
  "workflow_version": "2.0"
}'

echo "$log_entry" >> "$logs_dir/issues_resolved.jsonl"
echo "ğŸ“ Activity log saved: $logs_dir/issues_resolved.jsonl"

# 5.2 Final summary
echo ""
echo "âœ… Issues-to-Solved Enhanced Version Completed!"
echo ""
echo "ğŸ“Š Summary:"
echo "   PR: #$pr_number"
echo "   Issues processed: $issues_count"  
echo "   Temporal branch: $current_branch"
echo "   Analysis: $analysis_file"
echo "   Implementation: $([[ "$impl_executed" == "true" ]] && echo "Executed" || echo "Deferred")"
echo "   Changes committed: $([[ "$changes_committed" == "true" ]] && echo "Yes" || echo "No")"
echo ""

if [[ "$changes_committed" == "true" ]]; then
    echo "ğŸ¯ Next steps:"
    echo "   1. PR #$pr_number has been updated with fixes"
    echo "   2. Associated issues will auto-close when PR is merged"  
    echo "   3. Request code review for the implemented changes"
fi
```

## CaracterÃ­sticas Mejoradas

### âœ… **Principios del /pr Command Aplicados**
- **Switch a rama temporal**: Detecta y cambia automÃ¡ticamente al branch correcto
- **Validaciones first**: Verifica PR y issues antes de proceder
- **Control del usuario**: 3 puntos de aprobaciÃ³n crÃ­ticos
- **Error handling**: Cleanup y mensajes claros en caso de fallo
- **Logging JSONL**: DocumentaciÃ³n estructurada como /pr

### ğŸ¤– **Uso de Sub-Agents**
- **code-reviewer**: AnÃ¡lisis profesional de issues y recomendaciones  
- **DelegaciÃ³n inteligente**: Task tool para anÃ¡lisis especializado
- **DocumentaciÃ³n**: AnÃ¡lisis guardado en `.claude/review/`

### ğŸ›¡ï¸ **Control y Seguridad**
- **Rama temporal obligatoria**: No trabaja en main/develop directamente
- **AprobaciÃ³n en cada fase**: Usuario controla anÃ¡lisis, implementaciÃ³n, commit
- **Reversible**: Usuario puede cancelar en cualquier momento
- **Audit trail**: Log completo de todas las decisiones

### ğŸ“Š **Minimalismo**
- **5 fases claras**: Setup â†’ Analysis â†’ Control â†’ Implementation â†’ Logging
- **Sin over-engineering**: Implementaciones targeted, no complejas  
- **Zero dependencies**: Usa herramientas git/gh nativas
- **Single responsibility**: Cada fase tiene un propÃ³sito especÃ­fico

## Flujo de Uso

```bash
# 1. Estar en PR con issues asociados
/pr main                    # Crear PR con temporal branch
/findings-to-issues         # Crear issues desde findings

# 2. Resolver issues de forma controlada
/issues-to-solved          # Nueva versiÃ³n mejorada
# â†’ Cambia a rama temporal automÃ¡ticamente
# â†’ Delega anÃ¡lisis a code-reviewer  
# â†’ Pide aprobaciÃ³n antes de implementar
# â†’ Commit solo con aprobaciÃ³n del usuario
```

**Resultado**: Workflow profesional, controlado y auditado que sigue las mejores prÃ¡cticas del comando /pr.